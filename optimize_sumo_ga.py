#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GA optimizer for SUMO traffic light timings across multiple scenarios (aristas).

- Discovers scenarios under a root directory (each scenario is a folder containing
  a SUMO configuration and network).
- Extracts existing tlLogic programs (from additional file if present, else from .net.xml).
- Optimizes ONLY phase durations (keeps the phase states as-is to ensure valid signal groups).
- Runs SUMO via TraCI to evaluate each candidate's fitness using traffic KPIs.
- Writes best override file (XML) per scenario and a JSON with metrics + CSV history.

Usage example (Windows / Linux / macOS):
    python optimize_sumo_ga.py --root ./sumo-federado --gens 20 --pop 30 --max-seconds 900
    python optimize_sumo_ga.py --root ./sumo-federado --only "arista 3" --gui

Requires:
    - SUMO installed and environment variable SUMO_HOME set.
    - Python packages: sumolib (comes with SUMO), traci (comes with SUMO).

Author: (generated by GPT-5 Pro)
"""

from __future__ import annotations
import argparse
import copy
import csv
import math
import os
import random
import sys
import time
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, List, Tuple, Any

# ---------------------- SUMO/TraCI bootstrap ----------------------

def _ensure_traci():
    if "SUMO_HOME" in os.environ:
        tools = os.path.join(os.environ["SUMO_HOME"], "tools")
        if tools not in sys.path:
            sys.path.append(tools)
    try:
        import traci  # type: ignore
        from sumolib import checkBinary  # type: ignore
    except Exception as e:
        raise SystemExit(
            "ERROR: No se pudo importar 'traci' o 'sumolib'. "
            "Asegúrate de que SUMO esté instalado y que la variable de entorno SUMO_HOME apunte a su carpeta raíz.\n"
            f"Detalle: {e}"
        )
    return traci, checkBinary

traci, checkBinary = _ensure_traci()

# ---------------------- Utilidades XML -----------------------------

def read_tl_programs(net_file: Path, additional_file: Path | None) -> Dict[str, List[Dict[str, Any]]]:
    """
    Devuelve un diccionario: { tl_id: [ {'state': str, 'duration': int}, ... ] }
    Prioriza el 'additional' si existe; en caso contrario toma los programas del .net.xml
    """
    programs: Dict[str, List[Dict[str, Any]]] = {}
    source_file = additional_file if (additional_file and additional_file.exists()) else net_file
    root = ET.parse(source_file.as_posix()).getroot()
    for tl in root.findall(".//tlLogic"):
        tl_id = tl.attrib["id"]
        phases = []
        for ph in tl.findall("phase"):
            dur = int(float(ph.attrib.get("duration", "0")))
            phases.append({"state": ph.attrib["state"], "duration": dur})
        if phases:
            programs[tl_id] = phases
    if not programs and source_file != net_file:
        # fallback: intenta desde net si el additional no tenía tlLogic
        root = ET.parse(net_file.as_posix()).getroot()
        for tl in root.findall(".//tlLogic"):
            tl_id = tl.attrib["id"]
            phases = []
            for ph in tl.findall("phase"):
                dur = int(float(ph.attrib.get("duration", "0")))
                phases.append({"state": ph.attrib["state"], "duration": dur})
            if phases:
                programs[tl_id] = phases
    return programs


def write_additional_override(out_file: Path, programs: Dict[str, List[Dict[str, Any]]]):
    """
    Escribe un archivo XML <additional> con los tlLogic y sus fases/states/durations.
    """
    additional = ET.Element("additional", {
        "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
        "xsi:noNamespaceSchemaLocation": "http://sumo.dlr.de/xsd/additional_file.xsd"
    })
    for tl_id, phases in programs.items():
        tl = ET.SubElement(additional, "tlLogic", {
            "id": tl_id, "type": "static", "programID": "GA", "offset": "0"
        })
        for ph in phases:
            ET.SubElement(tl, "phase", {
                "duration": str(int(ph["duration"])),
                "state": ph["state"]
            })
    tree = ET.ElementTree(additional)
    out_file.parent.mkdir(parents=True, exist_ok=True)
    tree.write(out_file.as_posix(), encoding="UTF-8", xml_declaration=True)


# ---------------------- Espacio de búsqueda (genes) ----------------

def build_gene_space(programs: Dict[str, List[Dict[str, Any]]],
                     min_green: int = 8, max_green: int = 60,
                     min_yellow: int = 3, max_yellow: int = 6,
                     min_allred: int = 2, max_allred: int = 8) -> Tuple[List[Tuple[int, int]], List[Tuple[str, int]]]:
    """
    Devuelve:
        - lista de límites [(lo, hi), ...] por gen (una fase = un gen de duración)
        - gene_map: [(tl_id, phase_index), ...] en el mismo orden
    Heurística: si la 'state' contiene 'G' o 'g' => fase verde, 'y' => amarilla, resto => all-red.
    """
    gene_bounds: List[Tuple[int, int]] = []
    gene_map: List[Tuple[str, int]] = []
    for tl_id, phases in programs.items():
        for idx, ph in enumerate(phases):
            s = ph["state"]
            if ("G" in s) or ("g" in s):
                lo, hi = min_green, max_green
            elif "y" in s:
                lo, hi = min_yellow, max_yellow
            else:
                lo, hi = min_allred, max_allred
            gene_bounds.append((lo, hi))
            gene_map.append((tl_id, idx))
    return gene_bounds, gene_map


def genome_to_programs(base_programs: Dict[str, List[Dict[str, Any]]],
                       genome: List[int],
                       gene_map: List[Tuple[str, int]]) -> Dict[str, List[Dict[str, Any]]]:
    """
    Inserta las duraciones del 'genome' en una copia de base_programs.
    """
    programs = copy.deepcopy(base_programs)
    assert len(genome) == len(gene_map), "Longitud del genoma no coincide con el mapeo de genes."
    for val, (tl_id, phase_idx) in zip(genome, gene_map):
        programs[tl_id][phase_idx]["duration"] = int(val)
    return programs


# ---------------------- Evaluación en SUMO -------------------------

def run_sumo_and_metrics(sumocfg: Path,
                         additional_override: Path,
                         step_limit: int = 1200,
                         with_gui: bool = False,
                         seed: int | None = None) -> Dict[str, float]:
    """
    Ejecuta SUMO con TraCI y devuelve KPIs agregados.
    KPIs:
      - avg_queue: promedio de vehículos detenidos (speed < 0.1) por step en toda la red.
      - avg_speed: velocidad media por step (m/s).
      - throughput: vehículos que llegan (arrived) durante la simulación.
      - avg_wait: suma de waiting times por step / steps (aprox. "road rage").
      - sim_duration: steps simulados.
    """
    binary = checkBinary("sumo-gui" if with_gui else "sumo")
    cmd = [
        binary, "-c", sumocfg.as_posix(),
        "--no-step-log", "true",
        "--time-to-teleport", "-1",
        "--waiting-time-memory", "120",
        "--duration-log.statistics", "true",
        "--quit-on-end", "true",
        "--additional-files", additional_override.as_posix()
    ]
    if seed is not None:
        cmd += ["--seed", str(seed)]
    if with_gui:
        # reduce rendering speed so it does not crawl
        cmd += ["--delay", "25"]

    traci.start(cmd)

        # Activa el programa GA si existe (evita conflicto con programID=0 del net/additional)
    try:
        for tl_id in traci.trafficlight.getIDList():
            try:
                traci.trafficlight.setProgram(tl_id, "GA")
            except Exception:
                # Si no existe "GA" para ese TL, lo dejamos como está
                pass
    except Exception:
        pass

    step = 0
    total_halting = 0.0
    total_speed_weighted = 0.0
    total_veh_count = 0.0
    total_waiting_time = 0.0
    total_arrived = 0

    try:
        while step < step_limit and (traci.simulation.getMinExpectedNumber() > 0 or step < 60):
            traci.simulationStep()
            step += 1

            # Queue / halting
            halting = 0
            speed_sum = 0.0
            veh_sum = 0
            for edge_id in traci.edge.getIDList():
                halting += traci.edge.getLastStepHaltingNumber(edge_id)
                vc = traci.edge.getLastStepVehicleNumber(edge_id)
                if vc > 0:
                    vmean = traci.edge.getLastStepMeanSpeed(edge_id)  # m/s
                    speed_sum += vmean * vc
                    veh_sum += vc
            total_halting += halting
            if veh_sum > 0:
                total_speed_weighted += speed_sum
                total_veh_count += veh_sum

            # Waiting time (sum per-vehicle current waiting time)
            wsum = 0.0
            for vid in traci.vehicle.getIDList():
                wsum += traci.vehicle.getWaitingTime(vid)
            total_waiting_time += wsum

            # Throughput
            total_arrived += len(traci.simulation.getArrivedIDList())

    finally:
        traci.close(False)

    avg_queue = total_halting / max(step, 1)
    avg_speed = (total_speed_weighted / total_veh_count) if total_veh_count > 0 else 0.0
    avg_wait = total_waiting_time / max(step, 1)

    return {
        "avg_queue": float(avg_queue),
        "avg_speed": float(avg_speed),
        "throughput": float(total_arrived),
        "avg_wait": float(avg_wait),
        "sim_duration": float(step),
    }


# ---------------------- Función de aptitud -------------------------

def compute_fitness(metrics: Dict[str, float],
                    w_queue: float = 0.45,
                    w_wait: float = 0.35,
                    w_throughput: float = 0.20) -> float:
    """
    Combina KPIs en una sola función de costo a minimizar.
    Menor queue y menor espera => mejor. Mayor throughput => mejor.
    Fitness = wQ * avg_queue + wW * avg_wait + wT * (sim_duration / max(throughput, 1))
    """
    inv_throughput = metrics["sim_duration"] / max(metrics["throughput"], 1.0)
    return w_queue * metrics["avg_queue"] + w_wait * metrics["avg_wait"] + w_throughput * inv_throughput


# ---------------------- GA primitives ------------------------------

def random_genome(gene_bounds: List[Tuple[int, int]]) -> List[int]:
    return [random.randint(lo, hi) for (lo, hi) in gene_bounds]


def tournament_select(pop: List[Tuple[List[int], float]], k: int = 3) -> List[int]:
    """
    pop: lista de (genome, fitness). Devuelve el mejor de k al azar.
    """
    aspirants = random.sample(pop, k=min(k, len(pop)))
    aspirants.sort(key=lambda t: t[1])  # menor fitness es mejor
    return copy.deepcopy(aspirants[0][0])


def crossover(p1: List[int], p2: List[int], prob: float = 0.9) -> Tuple[List[int], List[int]]:
    if random.random() > prob or len(p1) < 2:
        return copy.deepcopy(p1), copy.deepcopy(p2)
    cut = random.randint(1, len(p1) - 1)
    c1 = p1[:cut] + p2[cut:]
    c2 = p2[:cut] + p1[cut:]
    return c1, c2


def mutate(g: List[int], gene_bounds: List[Tuple[int, int]], prob: float = 0.15, sigma: float = 3.0) -> List[int]:
    """
    Mutación gaussiana truncada a [lo, hi].
    """
    out = g[:]
    for i, (lo, hi) in enumerate(gene_bounds):
        if random.random() < prob:
            val = int(round(random.gauss(out[i], sigma)))
            out[i] = max(lo, min(hi, val))
    return out


# ---------------------- Evaluador de población ---------------------

def evaluate_genome_in_scenario(genome: List[int],
                                gene_map: List[Tuple[str, int]],
                                base_programs: Dict[str, List[Dict[str, Any]]],
                                tmp_dir: Path,
                                sumocfg: Path,
                                step_limit: int,
                                with_gui: bool,
                                seed: int,
                                weights: Tuple[float, float, float],
                                cache: Dict[Tuple[int, ...], Tuple[float, Dict[str, float]]]) -> Tuple[float, Dict[str, float]]:
    key = tuple(genome)
    if key in cache:
        return cache[key]

    programs = genome_to_programs(base_programs, genome, gene_map)
    override_file = tmp_dir / "ga_override_additional.xml"
    write_additional_override(override_file, programs)

    metrics = run_sumo_and_metrics(sumocfg, override_file, step_limit=step_limit, with_gui=with_gui, seed=seed)
    fitness = compute_fitness(metrics, *weights)
    metrics["fitness"] = float(fitness)
    cache[key] = (fitness, metrics)
    return fitness, metrics


# ---------------------- Descubrimiento de escenarios ---------------

def discover_scenarios(root: Path, only: List[str] | None = None) -> List[Path]:
    """
    Busca carpetas que contengan un .sumocfg.
    Si 'only' se provee, filtra por nombres de carpeta que contengan esas substrings.
    """
    scenarios: List[Path] = []
    for d in sorted(root.iterdir()):
        if not d.is_dir():
            continue
        if only and not any(sub.lower() in d.name.lower() for sub in only):
            continue
        cfgs = list(d.glob("*.sumocfg"))
        if cfgs:
            scenarios.append(d)
    return scenarios


def find_net_and_additional(scenario_dir: Path) -> Tuple[Path, Path | None, Path]:
    """
    Intenta ubicar:
        - net_file: *.net.xml (el primero)
        - additional_file: semaforo_*.xml (si existe), en caso contrario None
        - sumocfg: *.sumocfg (el primero)
    """
    net_files = sorted(scenario_dir.glob("*.net.xml"))
    if not net_files:
        raise FileNotFoundError(f"No se encontró .net.xml en {scenario_dir}")
    net_file = net_files[0]

    add_files = sorted(scenario_dir.glob("semaforo_*.xml"))
    additional = add_files[0] if add_files else None

    cfg_files = sorted(scenario_dir.glob("*.sumocfg"))
    if not cfg_files:
        raise FileNotFoundError(f"No se encontró .sumocfg en {scenario_dir}")
    sumocfg = cfg_files[0]

    return net_file, additional, sumocfg


# ---------------------- Loop principal por escenario ---------------

def run_ga_on_scenario(scenario_dir: Path,
                       gens: int,
                       pop_size: int,
                       step_limit: int,
                       seed: int,
                       with_gui: bool,
                       weights: Tuple[float, float, float],
                       bounds: Tuple[int, int, int, int, int, int]) -> Dict[str, Any]:
    random.seed(seed)

    net_file, additional, sumocfg = find_net_and_additional(scenario_dir)
    base_programs = read_tl_programs(net_file, additional)
    if not base_programs:
        raise RuntimeError(f"No se encontraron tlLogic en {scenario_dir.name} (net: {net_file.name}).")

    min_green, max_green, min_yellow, max_yellow, min_allred, max_allred = bounds
    gene_bounds, gene_map = build_gene_space(base_programs,
                                             min_green=min_green, max_green=max_green,
                                             min_yellow=min_yellow, max_yellow=max_yellow,
                                             min_allred=min_allred, max_allred=max_allred)

    tmp_dir = scenario_dir / "_ga_tmp"
    tmp_dir.mkdir(exist_ok=True, parents=True)

    # Inicializa población
    population: List[List[int]] = [random_genome(gene_bounds) for _ in range(pop_size)]
    evaluated: List[Tuple[List[int], float]] = []
    cache: Dict[Tuple[int, ...], Tuple[float, Dict[str, float]]] = {}

    # Evalúa población inicial
    for g in population:
        f, m = evaluate_genome_in_scenario(g, gene_map, base_programs, tmp_dir, sumocfg, step_limit, with_gui, seed, weights, cache)
        evaluated.append((g, f))

    history_rows = []

    # Bucle evolutivo
    for gen in range(gens):
        evaluated.sort(key=lambda t: t[1])  # best first
        best_g, best_f = evaluated[0]
        _, best_m = cache[tuple(best_g)]
        history_rows.append({
            "gen": gen,
            "best_fitness": best_f,
            "avg_queue": best_m["avg_queue"],
            "avg_wait": best_m["avg_wait"],
            "throughput": best_m["throughput"],
            "avg_speed": best_m["avg_speed"],
        })

        # Reproducción (elitismo + torneo + crossover + mutación)
        next_pop: List[List[int]] = [copy.deepcopy(best_g)]  # elitismo 1
        while len(next_pop) < pop_size:
            p1 = tournament_select(evaluated, k=3)
            p2 = tournament_select(evaluated, k=3)
            c1, c2 = crossover(p1, p2, prob=0.9)
            c1 = mutate(c1, gene_bounds, prob=0.15, sigma=3.0)
            c2 = mutate(c2, gene_bounds, prob=0.15, sigma=3.0)
            next_pop.extend([c1, c2])
        population = next_pop[:pop_size]

        evaluated = []
        for g in population:
            f, _ = evaluate_genome_in_scenario(g, gene_map, base_programs, tmp_dir, sumocfg, step_limit, with_gui, seed, weights, cache)
            evaluated.append((g, f))

    # Resultado final
    evaluated.sort(key=lambda t: t[1])
    best_genome, best_f = evaluated[0]
    best_metrics = cache[tuple(best_genome)][1]

    # Escribe override definitivo
    best_programs = genome_to_programs(base_programs, best_genome, gene_map)
    out_override = scenario_dir / "ga_best_additional.xml"
    write_additional_override(out_override, best_programs)

    # Registra historia y métricas
    out_json = scenario_dir / "ga_best_metrics.json"
    with open(out_json.as_posix(), "w", encoding="utf-8") as f:
        json.dump(best_metrics, f, indent=2, ensure_ascii=False)

    out_csv = scenario_dir / "ga_history.csv"
    with open(out_csv.as_posix(), "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=list(history_rows[0].keys()))
        writer.writeheader()
        writer.writerows(history_rows)

    return {
        "scenario": scenario_dir.name,
        "override_file": out_override.as_posix(),
        "metrics_json": out_json.as_posix(),
        "history_csv": out_csv.as_posix(),
        "best_fitness": best_f,
        "best_metrics": best_metrics,
        "num_tl": len(base_programs),
        "num_genes": len(best_genome),
    }


# ---------------------- CLI ---------------------------------------

def main():
    parser = argparse.ArgumentParser(description="GA optimizer for SUMO traffic lights across scenarios.")
    parser.add_argument("--root", type=str, required=True,
                        help="Carpeta raíz que contiene subcarpetas por escenario (p.ej., ./sumo-federado).")
    parser.add_argument("--only", type=str, default="",
                        help="Filtra escenarios por subcadenas separadas por comas (ej: \"arista 1,arista 3\").")
    parser.add_argument("--gens", type=int, default=15, help="Número de generaciones.")
    parser.add_argument("--pop", type=int, default=20, help="Tamaño de la población.")
    parser.add_argument("--max-seconds", type=int, default=900, help="Máximo de steps a simular por evaluación.")
    parser.add_argument("--seed", type=int, default=42, help="Semilla aleatoria.")
    parser.add_argument("--gui", action="store_true", help="Usar sumo-gui para visualizar.")
    parser.add_argument("--wq", type=float, default=0.45, help="Peso de avg_queue en fitness.")
    parser.add_argument("--ww", type=float, default=0.35, help="Peso de avg_wait en fitness.")
    parser.add_argument("--wt", type=float, default=0.20, help="Peso de componente de throughput (inverso).")
    parser.add_argument("--min-green", type=int, default=8)
    parser.add_argument("--max-green", type=int, default=60)
    parser.add_argument("--min-yellow", type=int, default=3)
    parser.add_argument("--max-yellow", type=int, default=6)
    parser.add_argument("--min-allred", type=int, default=2)
    parser.add_argument("--max-allred", type=int, default=8)

    args = parser.parse_args()

    root = Path(args.root).resolve()
    only = [s.strip() for s in args.only.split(",") if s.strip()] if args.only else None

    weights = (args.wq, args.ww, args.wt)
    bounds = (args.min_green, args.max_green, args.min_yellow, args.max_yellow, args.min_allred, args.max_allred)

    scenarios = discover_scenarios(root, only=only)
    if not scenarios:
        raise SystemExit(f"No se encontraron escenarios con .sumocfg bajo: {root}")

    print(f"Escenarios encontrados: {[d.name for d in scenarios]}")

    summary = []
    start_all = time.time()
    for sc_dir in scenarios:
        print(f"\n=== Escenario: {sc_dir.name} ===")
        t0 = time.time()
        result = run_ga_on_scenario(
            sc_dir, gens=args.gens, pop_size=args.pop,
            step_limit=args.max_seconds, seed=args.seed,
            with_gui=args.gui, weights=weights, bounds=bounds
        )
        dt = time.time() - t0
        print(f"✔ Terminado {sc_dir.name} en {dt:.1f}s | best fitness={result['best_fitness']:.3f}")
        print(f"   Override: {result['override_file']}")
        print(f"   Metrics : {result['metrics_json']}")
        print(f"   History : {result['history_csv']}")
        summary.append(result)

    dt_all = time.time() - start_all
    print("\n=== Resumen ===")
    for r in summary:
        print(f"- {r['scenario']}: best fitness={r['best_fitness']:.3f}, genes={r['num_genes']}, tl={r['num_tl']}")
    print(f"\nTiempo total: {dt_all:.1f}s")


if __name__ == "__main__":
    main()
